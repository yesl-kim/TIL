# 데이터 타입

> 코어 자바스크립트의 1장 데이터타입 부분을 보고 요약, 정리한 글

### 원시타입

원시 타입은 변경 불가능한 값(immutable value)이다.

- Boolean
- Null
- undefined
- String
- Number
- Symbol (new in ES6)

---

## 요약

- 자바스크립트의 데이터 타입은 기본형과 참조형으로 나눌 수 있다.

- 기본형은 원시타입의 값, 즉 number, string, boolean, null, undefined, 그리고 ES6에 추가된 symbol이 있다.

- 참조형은 object, array, function 등이다.

- 기본형은 불변형이며, 참조형은 가변형이다.

- 불변성을 말할 때의 '불변'이란 변수에 재할당의 가능여부를 말하는 것이 아니다(변경 가능성 x)

- 객체를 가변값이라고 하는 이유는, 객체 자체가 가지고 있는 주소값이 변경되지 않은 채 그 내부 프로퍼티의 값이 변경될 수 있기 때문.

- undefined는 값을 지정하지 않음을, null은 '값이 없음'을 사용자가 명시적으로 지정한 값임을 나타낸다.  
  undefined는 값을 지정하지 않음을 나타내는, 자바스크립트가 자동으로 내뱉는 값이지만, 사용자가 명시적으로 undefined 값을 부여할 수도 있다. 이 점은 혼란을 빚을 수 있어 지양하도록 한다.  
  -> '값이 없음'을 나타낼 땐 null 값을 사용한다. (사용자도 의도적으로 값을 지정하지 않은 것과 값이 없는 것을 구분하도록 한다)

- null값의 타입은 객체이다.

- null과 undefined의 비교는 ===로 비교한다.

---

## Intro

### 메모리와 데이터

- 0과 1. 둘 중 하나의 값만을 가지는 데이터를 비트라고 한다.
- 데이터를 확인하는 데에 효율성을 위해 데이터를 적정하게 그룹핑한 것이 바이트
- 모든 데이터는 위치를 확인하는 식별자를 가지며(메모리 주솟값) 이를 통해 서로 구분하고 연결할 수 있다.

### 변수와 식별자

- 변수는 값 (데이터)
- 식별자는 변수명

## 변수 선언과 데이터 할당, 복사

```js
// 예시
var a; // 변수 선언
a = 1; // 데이터 할당

var b = a; // 변수 복사
```

자바스크립트에서는,  
변수를 선언하면,

1. 값이 할당되지 않아도 일단 메모리 공간을 확보하고
2. 공간의 이름을 선언된 변수명으로 설정한다.

변수에 데이터가 할당되면,

1. 메모리에 해당 데이터가 있는지 확인하고,
2. 데이터가 없으면 메모리 공간을 확보한 뒤 값을 저장하고,
3. 그 메모리 주솟값을 변수의 값으로 저장한다.  
   데이터가 있으면 해당 메모리 주솟값을 변수의 값으로 저장한다.

변수가 복사될 때는,

- 변수가 가리키는 메모리 주솟값을 복사해오기 때문에, 복사된 변수끼리 같은 주소값의 메모리를 참조하고 있는 것과 같다.

## 기본형 데이터와 참조형 데이터: 불변값과 가변값

결국 기본형도, 참조형도 모든 변수는 식별자가 변수값을 참조하고 있는 형태라고 할 수 있다. 하지만 그 깊이가 달라서 불변성이 달라지는 것 같다.

(개인적으로 그려본 밑의 구조는 책을 바탕으로 요약한 것. 책의 설명 또한 이 부분은 저자의 개인적인 견해임을 밝혔다.)

- 기본형 데이터와 참조형 데이터의 구조
  ![](https://github.com/yesl-kim/TIL/blob/main/JS/%EB%8D%B0%EC%9D%B4%ED%84%B0%20%ED%83%80%EC%9E%85/%EA%B8%B0%EB%B3%B8%ED%98%95%EB%8D%B0%EC%9D%B4%ED%84%B0%20vs%20%EC%B0%B8%EC%A1%B0%ED%98%95%20%EB%8D%B0%EC%9D%B4%ED%84%B0.png?raw=true)

- 각 데이터를 복사했을 때
  ![](https://github.com/yesl-kim/TIL/blob/main/JS/%EB%8D%B0%EC%9D%B4%ED%84%B0%20%ED%83%80%EC%9E%85/%EA%B8%B0%EB%B3%B8%ED%98%95%EB%8D%B0%EC%9D%B4%ED%84%B0%20vs%20%EC%B0%B8%EC%A1%B0%ED%98%95%20%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%B3%B5%EC%82%AC.png?raw=true)

- 복사한 변수의 값을 변경했을 때
  ![](https://github.com/yesl-kim/TIL/blob/main/JS/%EB%8D%B0%EC%9D%B4%ED%84%B0%20%ED%83%80%EC%9E%85/%EA%B8%B0%EB%B3%B8%ED%98%95%EB%8D%B0%EC%9D%B4%ED%84%B0%20vs%20%EC%B0%B8%EC%A1%B0%ED%98%95%20%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%B3%80%EA%B2%BD.png?raw=true)

## 불변객체

- 객체의 가변성은, 값의 변경 전, 후를 안전하게 비교할 수 없게 하여 문제가 될 수 있다.

- 객체의 프로퍼티를 바로 건드리는 것이 아니라, 복사본을 만든 후 이를 변경하는 식으로 위의 문제를 해결할 수 있다.

## 객체 복사

- 객체를 복사하는 방법은 얕은 복사와 깊은 복사가 있다.  
  얕은 복사는 객체의 바로 아래 프로퍼티만 복사하는 것.  
  중첩된 객체의 경우, 프로퍼티가 다시 객체를 참조하면 이를 예방할 수 없다.  
  때문에 깊은 복사를 사용한다.  
  깊은 복사는 객체를 복사하는 함수를 재귀적으로 실행함으로써 달성할 수 있다.

- 전개연산자를 활용하는 것도 얕은 복사

(직접 함수를 작성하는 방법은 생략)

### JSON 활용

- JSON 메소드를 통해 객체의 프로퍼티 값들을 모두 문자열로 바꾼 후에 다시 객체로 파싱하는 방법

- 메서드나 *proto*나 getter/setter와 같이 json으로 변경할 수 없는 프로퍼티는 무시  
  -> 값을 잃을 수 있음  
  -> 정보형의 객체에만 사용권장

```js
function(targetObj) {
  return JSON.parse(JSON.stringify(targetObj))
}
```
