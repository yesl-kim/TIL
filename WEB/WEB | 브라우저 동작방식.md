웹이 어떻게 동작하나
Basic
클라이언트, 즉 일반적으로 웹 브라우저에서 데이터를 요청하면 서버에서 요청한 데이터를 반환해주고, 브라우저는 받은 데이테를 화면에 표시한다.
정리하면 클라이언트 측에서 데이터를 요청하고 서버에서 요청에 응답하는 방식으로 웹은 동작한다.
이때 데이터는 http(HyperText ~ Protocl) 규칙을 따른다. 클라이언트와 서버가 실제 주고 받는 메세지라고 할 수 있겠다.

~~이게 내가 아는 전부~~

---

# 웹 브라우저는 어떻게 동작하는가

> [네이버 D2 | 브라우저는 어떻게 동작하는가](https://d2.naver.com/helloworld/59361).

## 1. 브라우저 소개

이 글에서는 오픈소스 브라우저, 크롬, 파이어폭스, 사파리를 중점을

브라우저의 주요 기능, 역할

- 브라우저는 사용자가 요청한 자원을 서버에 요청하고 화면에 표시하는 역할을 한다.
- 자원의 주소는 URI(Uniform Resource Identifier)에 의해 정해진다.

브라우저의 기본 구조
![브라우저의 주요 구성 요소](https://d2.naver.com/content/images/2015/06/helloworld-59361-1.png)

1. 사용자 인터페이스
   - 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등
   - 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분
2. 브라우저 엔진
   - 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어
3. 렌더링 엔진
   - 요청한 콘텐츠를 표시
4. 통신
   - HTTP 요청과 같은 네트워크 호출에 사용
   - 플랫폼 독립적인 인터페이스이며 각 플랫폼 하부에서 실행됨
5. UI 백엔드
   - 콤보 박스와 창 같은 기본적인 장치를 그림
   - 기본적인 위젯을 그리는 인터페이스 (select, input 등)
   - 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용
6. 자바스크립트 해석기
   - 자바스크립트 코드를 해석하고 실행
7. 자료 저장소
   - 자료를 저장하는 계층
   - 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장

크롬은 대부분의 브라우저와 달리 각 탭마다 별도의 렌더링 엔진 인스턴스를 유지한다. 각 탭은 독립된 프로세스로 처리된다.

---

## 2. 렌더링 엔진

렌더링 엔진의 역할은 요청받은 내용을 브라우저 화면에 표시하는 일이다.

- 렌더링 엔진의 종류
  파이어폭스 : 모질라에서 직접 만든 **게코(Gecko)** 엔진
  사파리, 크롬 : **웹킷(Webkit)** 엔진

### 2-1. 렌더링 엔진의 동작 과정

렌더링 엔진은 통신으로붙 요청한 문서의 내용을 얻는 것으로 시작하는데 문서의 내용은 보통 8KB 단위로 전송된다.

**렌더링 엔진의 동작 과정**

1. HTML 파싱과 DOM 트리 구축
2. 렌더 트리 구축
3. 렌더 트리 배치
4. 렌더 트리 그리기

렌더링 엔진은 html문서를 파싱하고 내부의 태그들을 dom 노드로 변환한다. 그 다음 css 파일과 함께 스타일 요소를 파싱하여 "렌더 트리"를 구축한다. 렌더 트리 생성 후엔 각 노드를 브라우저 화면의 정확한 위치에 배치한다. 이를 렌더 트리 배치라고 한다. 다음은 ui 백엔드에서 렌더 트리의 각 노드를 가로지르며 형상을 만들어내는 그리기 과정이다. (??)

이러한 일련의 과정들은 한 단계가 모두 완료된 후에 다음 단계로 넘어가는 것이 아니라 점진적으로 진행된다. 렌더링 엔진은 노드를 가능한 빨리 화면에 표시하기 위해 모든 html이 파싱될 때까지 기다리지 않고 배치와 그리기를 함께 진행한다. 네트워크로부터 나머지 내용을 기다리면서 전송받은 내용은 먼저 화면에 표시하는 것이다.

![웹킷 동작 과정](https://d2.naver.com/content/images/2015/06/helloworld-59361-3.png)
![게코 동작 과정](https://d2.naver.com/content/images/2015/06/helloworld-59361-4.png)

---

## 3. 파싱과 DOM 트리 구축

문서 파싱은 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것을 의미한다. 파싱 결과는 보통 문서 구조를 나타내는 노드 트리인데 파싱 트리(parse tree) 또는 문법 트리(syntax tree)라고 부른다.

파싱은 문서에 작성된 언어 또는 형식의 규칙에 따르는데 파싱할 수 있는 모든 형식은 정해진 용어와 구문 규칙에 따라야 한다. 이것을 **문맥 자유 문법**이라고 한다.

### 3-1. 파서-어휘 분석기 조합

파싱 : 어휘분석과 구문 분석, 어휘 분석기와 파서

어휘 분석은 자료를 토큰으로 분해하는 과정이다. 토큰은 유효하게 구성된 단위의 집합체로 용어집이라고도 할 수 있는데 인간의 언어로 말하자면 사전에 등장하는 모든 단어에 해당된다.

구문 분석은 언어의 구문 규칙을 적용하는 과정이다.

파싱은 보통 자료를 유효한 토큰으로 분해하는 어휘 분석기와 언어 구문 규칙에 따라 문서 구조를 파싱 트리로 생성하는 파서, 이렇게 두가지의 일을 한다. 이러한 파싱 과정은 반복된다.

어휘 분석기는 유효한 토큰을 전달하고, 전달받은 토큰이 구문 규칙에 맞으면 파서는 파싱 트리에 추가

어휘 분석기가 토큰을 전달하면 파서는 구문 규칙에 따라 전달받은 토큰이 규칙에 따르면 파싱 트리에 추가하고 규칙에 맞지 않으면 예외로 처리한다. 후엔 다시 어휘 분석기에 새로운 토큰을 요청하는 식으로 반복된다.

이렇게 생성된 파서 트리는 최종 결과물이 아니다. 파싱은 보통 문서를 다른 양식으로 변환하는데 컴파일이 하나의 예가 된다. 소스 코드를 기계 코드로 만드는 컴파일러는 파싱 트리 생성 후 이를 기계 코드 문서로 변환한다.

#### 파서의 종류 : 상향식 파서와 하향식 파서

파서에는 상향식 파서와 하향식 파서가 있다.

상향식 파서는 구문의 낮은 수준에서 점차 높은 수준을 찾고 하햐식 파서는 높은 수준에서 낮은 수준을 찾는다.

파서를 생성해 줄 수 있는 도구를 파서 생성기라고 하는데 웹킷은 잘 알려진 두 개의 파서 생성기를 사용한다. 어휘 생성을 위한 플렉스(Flex)와 파서 생성을 위한 바이슨(Bison)이다. 플렉스는 토큰의 정규표현식 정의를 포함하는 파일을 입력 받고 바이슨은 BNF 형식의 언어 구문 규칙을 전달 받는다.

---

HTML의 정의는 DTD 형식 안에 있는데 DTD는 문맥 자유 문법이 아니다. (??)

### 3-2. DOM

파싱 트리는 dom 요소와 속성 노드의 트리로서 출력 트리가 된다.

파싱 트리는 DOM 요소와 속성 노드를 포함하는 트리로 출력 트리가 된다. DOM(Document Object Model)은 HTML 문서의 객체 표현이고 외부를 향하는 자바스크립트와 같은 HTML 요소의 연결 지점이다. 트리의 최상위 객체는 문서이다.

트리가 DOM 노드를 포함한다고 말하는 것은 DOM 접점의 하나를 실행하는 요소를 구성한다는 의미다. 브라우저는 내부의 다른 속성들을 이용하여 이를 구체적으로 실행한다.

### 3-3. 파싱 알고리즘

앞서 말한대로 HTML은 일반적인 하향식 또는 상향식 파서로 파싱이 안되는데 그 이유는 다음과 같다.

1. 언어의 너그러운 속성
2. 잘 알려져 있는 HTML 오류에 대한 브라우저의 관용
3. 변경에 의한 재파싱  
   document.write을 포함하고 있는 스크립트 태그는 토큰을 추가할 수 있기 때문에 파싱이 수정된다.

일반적인 파싱기술을 사용할 수 없기 때문에 브라우저는 HTML 파싱을 위해 별도의 파서를 생성한다.

파싱 알고리즘은 토큰화와 트리 구축, 두 단계로 되어 있다.

토큰화는 어휘 분석으로서 입력 값을 토큰으로 파싱한다. HTML 문서에서 토큰은 시작 태그, 종료 태그, 속성, 속성값이다.

토큰화는 토큰을 인지해서 트리 생성기로 넘긴 후에 다른 토큰을 전달하기 위해 다음 문자를 확인한다. 이와 같은 과정을 반복한다.

트리 구축이 진행되는 동안 문서 최상단에서는 DOM 트리가 수정되고 요소가 추가된다. 토큰화에 의해 발행된 각 노드는 트리 생성자에 의해 처리된다. DOM 트리에 요소를 추가하거나 열린 요소는 스택에 추가된다. 이 스택은 부정확한 중첩과 종료되지 않은 태그를 교정한다. 참고로 이때의 알고리즘은 "삽입 모드" 이다.

파싱이 끝나면 브라우저는 문서와 상호작용할 수 있게 되고 "지연 모드"에서 스크립트를 파싱하기 시작한다. 문서 상태는 "완료"가 되고 "로드" 이벤트가 발생한다.

### 3-4. CSS 파싱

HTML과 다르게 CSS는 문맥 자유 문법이고 따라서 파서 유형을 이용하여 파싱이 가능하다.

웹킷은 플렉스와 바이슨 파서 생성기를 사용하여 자동으로 파서를 생성하고, 파이어폭스는 직접 작성한 하향식 파서로 CSS 파일을 파싱한다. 두 경우 모두 CSS 파일을 스타일 객체로 파싱한다.

### 3-5. 스트립트와 스타일 시트의 진행순서

#### 스크립트

웹은 파싱과 실행이 동시에 수행되는 동기화(synchronous) 모델이다. 파서가 스크립트 태그를 만나면 문서의 파싱을 중단하고 스크립트 먼저 파싱 후 실행한다. 이는 스크립트가 외부에 있는 경우 또한 마찬가지이다. 네트워크로부터 자원을 가져오는데 자원을 가져오는 동안 문서의 파싱은 중단된다.

제작자는 스크립트를 지연(defer)으로 표시할 수 있는데 지연으로 표시하게 되면 위와 같은 문제를 해결할 수 있다. 즉, 중간에 파싱이 멈추지 않고 문서 파싱이 완료된 후에 스크립트가 실행된다. html5는 스크립트를 비동기로 처리하는 속성을 추가했기 때문에 별도의 맥락에 의해 파싱되고 실행된다.

#### 스타일 시트 (??)

한편 스타일 시트는 다른 모델을 사용한다. 이론적으로 스타일 시트는 DOM 트리를 변경하지 않기 때문에 문서 파싱을 기다리거나 중단할 이유가 없다. 그러나 스크립트에서 스타일 정보를 요청하는 경우라면 문제가 된다. 이때 스타일이 파싱되지 않은 상태라면 스크립트는 잘못된 결과를 내놓기 때문이다. 이는 매우 빈번하게 발생한다. 파이어폭스는 아직 로드 중이거나 파싱 중인 스타일 시트가 있는 경우 모든 스크립트의 실행을 중단한다. 한편 웹킷은 로드되지 않은 스타일 시트 가운데 문제가 될만한 속성이 있을 때에만 스크립트를 중단한다.

Q1. 스타일 시트는 html 문서의 파싱을 중단하지 않고 파싱된다. 아니면 스타일시트는 html, 스크립트 어떤 문서의 파싱도 중단하지 않고 파싱된다는 걸까
아니면 파서가 스크립트 태그를 만나도 스타일 시트의 파싱은 중단하지 않는다는 걸까

---

## 4. 렌더 트리 구축

dom 트리가 구축된 후에는 렌더 트리가 생성이 된다. dom트리가 html 문서 구조를 구축했다면 렌더 트리는 이 문서를 실제로 그리고 화면 상에 배치하는 역할을 한다.
