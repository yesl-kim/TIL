# virtual dom과 reconciliation

## virtual dom

가상 돔이란, 메모리에 저장된, (화면에 렌더링 x) 실제 돔을 경량화한 버전의 객체

왜 가상 돔인가, (등장배경 및 어떤 문제를 해결하는지)

- 결국 다시 렌더링
- html 문서를 화면에 렌더링하기 위해서는 많은 과정과 연산이 필요하다 (파싱 -> 렌더트리 구축 -> 각 위치와 색상 값 계산 -> 렌더링까지)
- 과거에는 정적 페이지가 많아, 생성된, 잘 만들어진 html을 서버에서 받아와 렌더링 했기 때문에 한 번 렌더링된 페이지에서 dom 조작 (및 변경)이 많지 않았다.
- 하지만 현재에 이르러 SPA가 등장하면서, 한 화면 내에서 DOM이 변경되는 일이 잦아졌다.
- 사소한 변경에도 매번 렌더링을 다시 하는 것은 비효율적이다. (앞서 말했듯이 렌더링 자체가 많은 연산을 요구하기 때문에)
- 이러한 이유로 가상 돔이 등장하게 되었다.

그럼 가상 돔은 어떤 문제를 해결하는가: 가상돔의 이점?

- 가상 돔은, 돔을 렌더링하기 전에? 화면에 렌더링하지 않은 메모리에만 저장된 객체
- 화면에 그릴 용도가 아니기 때문에 돔 트리를 표현하는 요소, 속성 등만 저장되고 DOM 관련 메소드는 저장되지 않는다. -> 경량화된 DOM 객체
- 돔을 실제 화면에 렌더링하기 전에, 잦은 변경사항들을 모아놓는 역할을 한다.
- 100번의 업데이트가 발생했을 때 가상 돔만 업데이트? 생성?한 후 최종 변경된 가상 돔을 실제 돔에 반영 -> 렌더링한다.
- 이를 통해 짧고 여러번의 렌더링으로 인한 버퍼링?, 그리고 비효율을 개선할 수 있다.

그러나! 이것이 가상 돔이 주는 단 하나의 이점은 아니다.
단순히 가상 돔이 여러 변경사항을 모아놓고 한 번에 렌더링하기 위한 것이라면, 다른 방법이 더 효율적일 수 있다.
~~그런데 변경사항을 모아놓고 한 번에 업데이트하는 건, 가상돔이 없어도 된다? 이게 더 효율적일 수도 있다? <- 이게 잘 감이 안옴~~

결국 가상 돔을 렌더링하기 위해서는 가상 돔과 실제 돔을 "비교"하며 "동기화"하는 작업이 필요한데, (이를 재조정이라 한다) 이 작업이 결코 간단하지 않다. 각 노드를 모두 순회해야하기 때문에.

오히려 가상 돔을 활용하여 노드를 일일히 비교하고 실제 돔에 반영하는 재조정의 과정을 추상화할 수 있다는 것에 더 큰 이점이 있다. 이를 통해 리액트에서는 더 쉽고 간편하게 돔을 조작할 수 있다.

그렇다면 리액트에서의 재조정 과정은? 자세히 알아보자 -> 어떤 식으로 돔을 비교하여 업데이트하는지

## reconciliation (재조정)

> [리액트 공식문서 | reconciliation (재조정)](https://ko.legacy.reactjs.org/docs/reconciliation.html)

해당 공식문서에서는 리액트가 리액트 엘리먼트 트리를 어떻게 구축하고 갱신하는지, 또 그 과정에서 비교 알고리즘이 어떻게 동작하는지를 설명하고 있다.

> Reconciliation? 엘리먼트 트리에 변경이 생겼을 때 변경점을 적용하는 것 (아예 새로운 트리를 구축한다거나, 변경된 부분만 갱신한다거나), 상태 업데이트

intro

- Render 함수란 **리액트 엘리먼트 트리**를 구축하는 함수이다.
- 일반적으로 트리 -> 다른 트리로 변환하는 작업은 최선의 알고리즘을 선택하더라도 시간 복잡도가 굉장히 크다 -> UI를 다루는 것에는 적용하기 어려움, 이마저도 너무 비효율

그래서 리액트가 채택한 비교 알고리즘은~~
그래서 리액트는 트리에 변경이 일어났을 때 엘리먼트의 타입이 변경된 경우에만 트리를 재생성하고 **그 외 경우엔(?)** 모두 변경된 부분만 갱신하고 있다.

리액트는 엘리먼트 전,후를 루트 엘리먼트부터 차례로 비교한다.

1. 엘리먼트 타입이 다를 경우
   - 이전 엘리먼트는 모두 파괴한다 -> 언마운트, 이전 엘리먼트의 속성, state 모두 제거된다.
   - 새로운 엘리먼트 트리를 구축한다 -> 마운트
2. 엘리먼트 타입이 같은 경우
   - dom 엘리먼트 타입이 같은 경우
     - 엘리먼트의 속성 비교 -> 변경된 부분만 갱신
     - 속성 비교 시 nested 객체도 비교하여 변경된 부분만 갱신
   - 컴포넌트 타입이 같은 경우
     - \* 컴포넌트는 변경이 일어났을 때 인스턴스의 state를 재사용한다.
     - props 갱신 -> 업데이트 발생 -> render 함수 호출을 통해 해당 컴포넌트의 자식 노드에 대해 비교 알고리즘 동작

자식노드의 비교

- 목록형 자식노드의 경우, 자식 노드 리스트를 순회하며 비교한다.
- 이때 맨 끝에 요소가 삽입,삭제,변경되는 경우 간단하지만, 처음~중간 요소가 변경되는 경우 혹은 순서가 변경되는 경우 모든 자식요소를 다시 그리게 되기 때문에 비효율이 발생한다. -> key 속성 사용
- 각 자식 노드의 식별자로 key 속성을 사용 -> key 값을 통해 자식 노드 비교 -> 갱신
- 때문에 key 값으로 인덱스를 사용하면 의도치 않은 오류가 발생할 수 있다.
  - key 값이 같으면 같은 요소라고 판단, 자식요소가 컴포넌트라면 state 또한 key 값이 같은 요소끼리 공유되기 때문에
- key 값을 항상 변하는 값 (ex. new Date(), Math.random())으로 설정하면 성능 저하
  - 불필요한 재생성

---

NEXT

- 선언적 API?
  - 리액트 API를 말하는 듯하다 (render, componentDidMound, ~~WillUpdate 같은)
  - 내부에 동작을 숨기고 함수만 드러내는 것?
- 그렇다면 엘리먼트의 전과 후는 어떻게 비교? 전과 후 (vdom)
- dom 트리 vs 리액트 엘리먼트 트리
- 엘리먼트 vs 리액트 엘리먼트 vs component
