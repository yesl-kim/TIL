# 시간복잡도

## 시간 복잡도

시간복잡도란 알고리즘을 수행하기 위해 프로세스가 수행해야하는 연산을 수치화 한 것이다.
간단히 말하면 프로세스가 수행해야하는 연산의 수를 나타낸 것

알고리즘이란?
간단히 말해 목표를 달성하기 위해 행해지는 일련의 과정이다.

서울에서 부산까지 가는 길과 수단이 많듯이 상황에 따른 알고리즘이 다양하기 때문에 시간이 가장 적게 드는 알고리즘을 선택하는 것이 중요한데, 알고리즘의 실행시간은 컴퓨터의 성능, 사용된 언어 종류, 컴파일러의 속도에 따라 다르다. 때문에 일반적으로 실제 실행시간이 아닌 **컴퓨터가 수행해야하는 연산의 횟수**로 알고리즘의 실행시간을 판별한다. 이를 **시간 복잡도**라고 한다.

> 시간 복잡도란? 알고리즘을 수행하기 위해 프로세스가 수행헤야하는 연산을 수치화한 것

이때 중요하지 않은 상수와 계수들을 제거하고 실행시간에 가장 크게 영향을 미치는 입력값 N에만 집중하여 표기한다. (이것을 점근적 표기법이라고 한다.)
시간 복잡도를 나타내는 표기법에는 

- 오메가 표기법 (Big-Ω Notation) : 최상의 경우
- 세타 표기법 (Big-⍬ Notation) : 평균의 경우
- 최악의 경우 (Big-O Notation) : 최악의 경우

여기서 최악의 경우인 빅오를 사용한다. 알고리즘이 최악일 때의 경우를 판단하면 평균과 가까운 성능으로 예측하기 쉽기 때문이다.

## 빅오 표기법

시간 복잡도의 문제 해결 단계 (실행시간이 빠른 순서)

- O(1) 상수 시간  
n의 단위에 상관없이 항상 일정한 시간이 유지된다.
- O(log N) 로그 시간  
문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어든다.
예) 이진검색
- O(N) 직선적 시간  
입력값과 처리시간이 비례하여 증가한다.
예) for 반복문. **하나의 루프**를 사용하여 단일 요소 집합을 반복하는 경우. (O(n), O(n/2), O(n+m))
- O(N log N)  선형 로그형
문제를 해결하기 위한 단계의 수가 N*(log2N) 번 만큼의 수행시간을 가진다.
예) 컬렉션 정렬을 사용하는 경우
- O(N^2) 2차 시간  
처리시간은 입력값의 제곱만큼 증가한다.
예) 두 개의 중첩 반복문
- O(C^N) 지수 시간  
처리시간은 상수값 C의 N 제곱의 관계를 갖는다.