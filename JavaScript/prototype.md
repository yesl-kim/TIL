# 프로토타입

> 정재남, 코어 자바스크립트, 위키북스

## 프로토타입 개념

![자바스크립트의 프로토타입](https://blog.kakaocdn.net/dn/d8bXKF/btqzKfhKKnA/oiWKbqLb3KqkKb07RBsi80/img.png)

- 프로토타입은 객체이다.

- `prototype` 객체 내부에는 인스턴스가 사용할 메소드를 저장한다.

- 자바스크립트는 함수에 자동으로 객체인 prototype 프로퍼티를 생성해놓고, 해당 함수를 생성자 함수로(new 키워드와 함께) 호출할 경우 그로부터 생성된 인스턴스에는 자동으로 `__proto__`라는 프로퍼티를 생성한다. 이 `__proto__` 프로퍼티는 생성자 함수의 prototype을 참조한다.

- 인스턴스의 `__proto__`프로퍼티는 생략이 가능하다.  
  즉, 인스턴스의 `__proto__`프로퍼티로 생성자 함수 prototype의 프로퍼티에 접근할 수 있지만, 인스턴스의 프로퍼티로도 prototype 프로퍼티에 바로 접근이 가능하다.  
   -> `인스턴스.__proto__.프로퍼티 = 인스턴스.프로퍼티`

- _"생성자 함수의 prototype에 어떤 메소드나 프로퍼티가 있다면 인스턴스에서도 마치 자신의 것처럼 해당 메소드나 프로퍼티에 접근할 수 있게 됩니다."_

- **실제 `__proto__`프로퍼티로 접근을 할 경우 `인스턴스.__proto__`가 아닌 `Object.getPrototypeOf(인스턴스)`가 권장되는 방법이다.**

- 프로토타입에는 constructor라는 프로퍼티가 있는데 이는 생성자 함수를 가리킨다. 이 프로퍼티는 인스턴스가 자신의 생성자 함수가 무엇인지를 알기 위함이다.

## 메소드 오버라이딩

- 같은 이름의 메소드나 프로퍼티를 인스턴스의 프로퍼티로 할당할 수도 있고, 인스턴스의 `__proto__`의 프로퍼티로 할당할 수도 있다.

- 이럴 경우 흔히 객체처럼 덮어쓰기되어 값이 교체되는 것이 아니라, (결국 다른 객체에 저장되는 것이니까..) 두 값 모두 보존이 된다.

```js
// 동시에 할당이 가능
var Person = function (name) {
  (this.name = name),
    (this.getName = function () {
      return this.name;
    });
};

Person.prototype.getName = function () {
  return `my name is ${this.name}`;
};

var p1 = new Person('ys')

// p1
// 이런 형태
Person {
  name: 'ys',
  getName: f (), // <--
  __proto__: {
    constructor: f Person (),
    getName: f () // <--
  }
}
```

## 프로토타입 체이닝

- 프로토타입은 결국 객체이기 때문에 (프로토타입 자체가 결국 객체의 인스턴스이기 때문에), `__proto__` 이 참조하는 프로토타입을 계속 찾아가면 결국 그 끝은 Object.prototype이다.

- 이렇게 `__proto__` 이 참조하는 프로토타입을 계속 찾아가는 과정을 **프로토타입 체이닝**이라고 하며, 이렇게 프로토타입이 연결되어 있는 것을 **프로토타입 체인**이라고 한다.

- 이 프로토타입 체이닝을 통해 각 프로토타입 메소드를 자신의 것처럼 호출할 수 있다. (`__proto__`가 생략이 가능하기 떄문에)

- 이때 호출된 메소드는 인스턴스로부터 가장 가까운 메소드가 실행된다.
