# virtual dom과 reconciliation

## reconciliation (재조정)

> [리액트 공식문서 | reconciliation (재조정)](https://ko.legacy.reactjs.org/docs/reconciliation.html)

해당 공식문서에서는 리액트가 리액트 엘리먼트 트리를 어떻게 구축하고 갱신하는지, 또 그 과정에서 비교 알고리즘이 어떻게 동작하는지를 설명하고 있다.

> Reconciliation? 엘리먼트 트리에 변경이 생겼을 때 변경점을 적용하는 것 (아예 새로운 트리를 구축한다거나, 변경된 부분만 갱신한다거나), 상태 업데이트

intro

- Render 함수란 **리액트 엘리먼트 트리**를 구축하는 함수이다.
- 일반적으로 트리 -> 다른 트리로 변환하는 작업은 최선의 알고리즘을 선택하더라도 시간 복잡도가 굉장히 크다 -> UI를 다루는 것에는 적용하기 어려움, 이마저도 너무 비효율

그래서 리액트가 채택한 비교 알고리즘은~~
그래서 리액트는 트리에 변경이 일어났을 때 엘리먼트의 타입이 변경된 경우에만 트리를 재생성하고 **그 외 경우엔(?)** 모두 변경된 부분만 갱신하고 있다.

리액트는 엘리먼트 전,후를 루트 엘리먼트부터 차례로 비교한다.

1. 엘리먼트 타입이 다를 경우
   - 이전 엘리먼트는 모두 파괴한다 -> 언마운트, 이전 엘리먼트의 속성, state 모두 제거된다.
   - 새로운 엘리먼트 트리를 구축한다 -> 마운트
2. 엘리먼트 타입이 같은 경우
   - dom 엘리먼트 타입이 같은 경우
     - 엘리먼트의 속성 비교 -> 변경된 부분만 갱신
     - 속성 비교 시 nested 객체도 비교하여 변경된 부분만 갱신
   - 컴포넌트 타입이 같은 경우
     - \* 컴포넌트는 변경이 일어났을 때 인스턴스의 state를 재사용한다.
     - props 갱신 -> 업데이트 발생 -> render 함수 호출을 통해 해당 컴포넌트의 자식 노드에 대해 비교 알고리즘 동작

자식노드의 비교

- 목록형 자식노드의 경우, 자식 노드 리스트를 순회하며 비교한다.
- 이때 맨 끝에 요소가 삽입,삭제,변경되는 경우 간단하지만, 처음~중간 요소가 변경되는 경우 혹은 순서가 변경되는 경우 모든 자식요소를 다시 그리게 되기 때문에 비효율이 발생한다. -> key 속성 사용
- 각 자식 노드의 식별자로 key 속성을 사용 -> key 값을 통해 자식 노드 비교 -> 갱신
- 때문에 key 값으로 인덱스를 사용하면 의도치 않은 오류가 발생할 수 있다.
  - key 값이 같으면 같은 요소라고 판단, 자식요소가 컴포넌트라면 state 또한 key 값이 같은 요소끼리 공유되기 때문에
- key 값을 항상 변하는 값 (ex. new Date(), Math.random())으로 설정하면 성능 저하
  - 불필요한 재생성

---

NEXT

- 선언적 API?
  - 리액트 API를 말하는 듯하다 (render, componentDidMound, ~~WillUpdate 같은)
  - 내부에 동작을 숨기고 함수만 드러내는 것?
- 그렇다면 엘리먼트의 전과 후는 어떻게 비교? 전과 후 (vdom)
- dom 트리 vs 리액트 엘리먼트 트리
- 엘리먼트 vs 리액트 엘리먼트 vs component
