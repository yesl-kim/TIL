> [리액트 공식문서](https://ko.reactjs.org/docs/hooks-intro.html)

## Hook이 도입된 이유

훅이 도입되기 이전의 함수형 컴포넌트는 자체 state를 가질 수 없었고, 상위 컴포넌트로부터 props를 전달받아 표현하는 컴포넌트(presentational component)로 사용되고 있었다.

하지만 훅이 도입되면서 그런 구분이 사라졌다. 함수형 컴포넌트도 클래스형과 같이 상태관리를 할 수 있고 라이프사이클을 표현할 수 있는 방법이 생겼다.

---

### 컴포넌트 사이에서 상태 로직을 재사용하기 어렵다.

리액트는 컴포넌트끼리 재사용 가능한 로직을 공유하는 기능을 제공하지 않는다. 예를 들어 변경된 인풋값을 제어하는 로직은 많이 쓰이는 상태 로직이지만 이를 함수만 따로 컴포넌트에서 분리하여 재사용할 수 없다. 이를 수행하기 위해서는 hoc(Higher-Order-Component, 고차 컴포넌트)와 render props를 사용해야 했다. 하지만 이런 패턴의 사용은 (컴포넌트 안에 컴포넌트 안에 컴포넌트) 컴포넌트를 다층의 레이어로 둘러쌓이게 하고 코드의 추적을 어렵게 한다.

하지만 커스텀 훅을 사용하면 계층의 변화없이 상태관련 로직을 분리하고 재사용할 수 있다.

> 커스텀 훅은 결국 그 내부에서 훅 api를 사용하고 있는 함수라고 할 수 있다.

### 관련없는 로직이 단일 메서드로 결합한다.

클래스 컴포넌트에서는 아무 관련 없는 로직도 라이프사이클에 따라 단일 메서드로 결합할 수 있고, 같은 로직이 다른 라이프사이클 메소드 안에서 중복으로 실행될 수도 있다. (예를 들면 같은 로직이 `componentDidMount`와 `componentDidUpdate` 안에서 중복 호출될 수 있다.) 이로 인해 버그가 쉽게 발생하고 무결성을 쉽게 해친다.

반면 훅을 사용하면 함수 단위로 (비슷한 것을 하는) 로직을 쪼갤 수 있다. -> 관심사 단위로

> "useEffect Hook을 componentDidMount와 componentDidUpdate, componentWillUnmount가 합쳐진 것으로 생각해도 좋습니다. -리액트 공식문서"

## 클래스는 사람과 기계를 혼동시킨다.

기본적으로 자바스크립의 this 동작방식을 알아야 하며, 이는 다른 언어에서와는 다르게 동작하기 때문에 사용자에게 혼란을 주었다.

또한 클래스형 컴포넌트는 코드의 최소화를 힘들게 하고, 핫 리로딩을 깨지기 쉽게 한다.

---

## Hook

> Hook은 함수 컴포넌트에서 React state와 생명주기 기능을 연동할 수 있게 해주는 함수

### Effect Hook

- 함수 컴포넌트 내에서 side effects를 수행하게 해주는 함수
- `componentDidMount`, `componentDidUpdate`, `componentWillUnmount` 와 같은 목적  
  `componentWillUnmount`를 쓰고 싶다면 -> 해제할 동작을 리턴해주면 됨

> side effect
> _이것은 다른 컴포넌트에 영향을 줄 수도 있고 렌더링 과정에서는 구현할 수 없는 작업이기 때문에 - 공식문서_
> 컴포넌트 안에서 처음 렌더링되는 것을 제외하고 동작하는 모든 동작

---

## Hook 사용 규칙

- 최상위에서만 hook을 호출해야한다.  
  중첩된 함수 (반복문, 조건문) 내에서 x
- 함수형 컴포넌트 내에서만 hook을 호출해야한다.  
  일반 자바스크립트 함수 내 x  
  클래스 컴포넌트 x
