22.04.18 (화)

## 인프런 | 함수형 프로그래밍과 ES6 입문

> 강의: 합성관점에서의 프로미스와 모나드, kleisli composition 관점에서의 프로미스

### 합성관점에서의 프로미스와 모나드

모나드는 함수를 안전하게 합성하도록 하는 도구이다.

모나드는 함수를 실행하기 위한 재료가 되는 데이터와 메소드의 연결을 통해 구현된다. eg. 배열의 메소드

```jsx
const arr1 = [1];
const arr2 = [];
arr2
  .map((a) => a + a)
  .map((a) => a * a)
  .forEach((a) => console.log(a));
```

- 이 때 아무런 값이 로그에 찍히지 않는데, 값이 없기 때문에 첫 map이 실행되지 않는 것
- 배열의 메소드는 배열의 인스턴스에서만 사용되고 배열 안의 값이 없으면 실행되지 않는다.
- 타입 체크와 값의 유무를 확인하여 함수 합성이 안전하게 이루어지고 있다.
- 중간에 filter를 통해 값이 없어지더라도 안전하게 실행된다.

이런 것 처럼 프로미스도 모나드의 구현체 중 하나.

프로미스는 배열의 메소드처럼 값이 없을 때의 상황을 안전하게 한다기보다는, 비동기 상황을 안전하게 합성하는 모나드라고 할 수 있다.

비동기로 평가되는 값을 동기적으로 평가되어 다음 함수에서 값을 안전하게 전달받을 수 있도록 한다. 그런 관점에서 프로미스를 모나드라고 할 수 있다.

### kleisli composition 관점에서의 프로미스

라고 쓰고 ‘프로미스를 활용하여 kleisli composition 규칙 적용하는 방법' 이라고 읽는다

- kleisli composition 은 오류가 일어날 수 있는 상황에서 함수를 안전하게 합성하는 방법을 말한다.
- 각각의 함수가 안전하게 동작하더라도, 합성된 함수는 안전하게 동작하지 않을 수 있다.
- 오류상황에도 함수를 안전하게 합성하기 위해서는, 오류상황에서 다음과 같은 규칙이 성립해야 한다.
  ```jsx
  f(g(x)) = g(x)
  ```
  즉, 합성된 함수에서 오류상황의 반환값과 g 함수에서 오류상황의 반환값이 같아야한다.
  이것은 **앞의 함수가 성공해야 다음 함수를 실행하는 것**과 같이 동작한다고 볼 수 있다.
- 이러한 규칙을 프로미스로 구현할 수 있다.
  프로미스의 체이닝을 통해
  ```jsx
  const users = [{ id: 1, name: "aa" }];
  ```
