22.04.09 (토)

## 인프런 | 함수형 프로그래밍과 ES6 입문

> 강의: L.flatMap, flatMap, 2차원 배열 다루기, 이터러블 중심 프로그래밍 실무적인 코드

### **flatMap의 기능**

- map → flatten
  - ~~flatten을 먼저 한 후에 map을 한다고 생각했는데, 이 미세한 차이가 아주 큰 차이를 만든다.. 둘은 엄연히 다르다!~~
- 자바스크립트에서 새롭게 추가된 flatMap은 내부적으로 L.map을 한 후에 L.flatten을 하는 것과 동일하게 동작한다. (지연성을 갖는다)
- 그냥 map → flatten 하는 것과 다른 것은 동작방식.
  - map → flatten은 새로운 2차 배열을 모두 만든 후에 flatten을 하는 반면
  - flatMap은 map과 flatten을 동시에
- ⇒ 결국 모든 값을 순회해야 한다면 시간복잡도에서는 차이가 없다. 다만 flatMap을 한 결과값에서 요소 몇가지만 필요하거나, 조건이 걸리는 경우 flatMap이 더 효율적이다. (지연성을 갖는 함수가 효율을 갖는 이유와 동일하게 생각하면 됨)

```jsx
const da1 = [[1, 2, 3], [4, 5], [6, 7], [8]];

// 둘은 기능적으로 동일
da1.flatMap((a) => a.map((a) => a * a));
flatten(da1.map((a) => a.map((a) => a * a)));
// flatten(map(map(a => a * a), da1))

// [ 1, 4, 9, 16, 25, 36, 49, 64 ]
```

### **L.flatMap, flatMap**

- 자바스크립트 내장 메소드 flatMap과 동일
- 하지만 배열 뿐 아니라 이터러블 프로토콜을 따르는 값에도 사용할 수 있는 함수
- ⇒ 조합성과 확장성이 더 좋다고 할 수 있다.

그래서 L.flatMap과 flatMap을 만들면

```jsx
L.flatMap = curry(pipe(L.map, L.flatten));
const flatMap = curry(pipe(L.map, flatten));
```

=> flatma

### 이터러블 중심 프로그래밍 실무적인 코드

객체지향 프로그래밍은 데이터를 먼저 짜놓은 상태에서 프로그래밍을 하는 반면, 함수형 프로그래밍은 함수를 조합하여 데이터를 원하는 형식에 맞게 구성하는 방식이다. 함수가 더 우위에 있는 프로그래밍 방식. 예를 들어 어떤 데이터가 있고 원하는 데이터를 위해 map을 하고 flatten하고 reduce해서 얻으면 되겠다~ 라고 생각하는게 함수형 프로그래밍적 사고

⇒ 함수를 어떻게 조합하여 데이터를 구성할 것인지

이렇게 고차함수와 보조함수를 조합하여 프로그래밍을 하는 것이 함수형 프로그래밍이고, List processing (리습?)이라고 하기도 한다. 또는 이터러블 중심의 프로그래밍.

---

### **Promise vs callback, 차이점은?**

> 강의: callback과 Promise, 비동기를 값으로 만드는 Promise, 값으로서의 Promise 활용

#### **callback**

- 비동기 함수의 컨텍스트 안에서만 결과값을 사용할 수 있다. 함수가 끝난 뒤에는 어떠한 일도 이어받아 실행할 수 없다.
- 비동기 상황을 다룬다는 것이 코드상으로만 표현이 된다.(콜백패턴) 함수가 끝난 뒤 아무런 값도 반환하지 않기 때문에 이 함수가 비동기 상황을 다루는지 아닌지 알 수 없다.

#### **Promise**

- 함수가 끝난 뒤에도 결과값을 통해 원하는 시점에 다시 원하는 동작을 이어갈 수 있다.

- 프로미스 객체는 프로미스의 인스턴스이기 때문에 결과값이 프로미스인지 아닌지 확인이 가능하고, 이를 통해 함수가 비동기를 다루는지도 구분이 가능하다.

프로미스와 콜백의 가장 중요한 차이점은 사용형식 (콜백 패턴, 메소드 체이닝)의 차이가 아니라, 프로미스가 **비동기 상태를 값으로 가진 프로미스 객체를 반환**한다는 데에 있다. (아무것도 반환하지 않는 콜백과 다르게) 즉, 프로미스는

- 비동기 상황을 **값으로 만들어서 반환**하고 있다.
- **일급의 성질**을 가지고 있다.

이러한 성질 때문에 아래와 같은 일들을 할 수 있다.

- 변수에 할당
- 함수에 전달
- 결과값이 프로미스인지 아닌지 확인

이런 점은 이렇게 활용이 가능! → 일반 함수처럼!

```js
const delay100 = a => {
  return new Promise(resolve => setTimeout(() => resolve(a)), 100)
}
const go1 = (a, f) => a instanceof Promise ? a.then(f) : f(a)

go1(go1(delay100(5), a => a + 10), log) // 15
go1(go1(5, a => a + 10)log) // 15
```
